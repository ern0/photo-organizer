#!/usr/bin/env python3

# Author: generated by DeepSeek, prompt by ern0
# License: MIT
# Project page: https://github.com/ern0/photo-organizer

import os
import sys
import argparse
import shutil
from datetime import datetime
from PIL import Image
from PIL.ExifTags import TAGS

class PhotoOrganizer:

    def __init__(self):

        self.source_path = ""
        self.target_path = ""
        self.date_filter = None
        self.dry_run = False
        self.log_file = None
        self.ignore_list = []

        self.stats = {
            'directories_processed': 0,
            'directories_skipped': 0,
            'directories_deleted': 0,
            'files_moved_unchanged': 0,
            'files_moved_renamed': 0,
            'files_skipped': 0,
            'files_deleted': 0
        }

        self.image_extensions = {'.jpg', '.jpeg', '.gif', '.png', '.bmp'}
        self.video_extensions = {'.avi', '.mov', '.mpg', '.mp4', '.3gp', '.m4v'}
        self.document_extensions = {'.pdf'}
        self.audio_extensions = {'.wav', '.mp3'}
        self.allowed_extensions = self.image_extensions | self.video_extensions | self.document_extensions | self.audio_extensions

        self.delete_files = {'Thumbs.db', '.DS_Store'}
        self.delete_prefixes = {'.trashed', '._'}
        self.delete_extensions = {'.exe', '.dll'}

    def setup_args(self):

        parser = argparse.ArgumentParser(description='Photo Organizer', formatter_class=argparse.RawDescriptionHelpFormatter)
        parser.add_argument('-s', '--source', required=True, help='Root source path')
        parser.add_argument('-t', '--target', required=True, help='Root target path')
        parser.add_argument('-f', '--filter', help='Date filter (YYYY-MM-DD)')
        parser.add_argument('-d', '--dry-run', action='store_true', help='Dry run')
        parser.add_argument('-l', '--log', help='Log file name')
        parser.add_argument('-i', '--ignore-list', nargs='*', default=[], help='Ignored directory list')

        args = parser.parse_args()

        self.source_path = os.path.abspath(args.source)
        self.target_path = os.path.abspath(args.target)
        self.dry_run = args.dry_run
        self.log_file = args.log
        self.ignore_list = [os.path.abspath(os.path.join(self.source_path, ignore))
                           for ignore in args.ignore_list]

        if args.filter:
            try:
                self.date_filter = datetime.strptime(args.filter, '%Y-%m-%d')
            except ValueError:
                self.log_message(f"Invalid date filter format: {args.filter}. Use YYYY-MM-DD")
                sys.exit(1)

        if self.log_file and os.path.exists(self.log_file):
            os.remove(self.log_file)

    def log_message(self, message):

        if self.log_file:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                f.write(message + '\n')
        else:
            print(message)

    def get_exif_date(self, file_path):

        try:
            if file_path.lower().endswith(('.jpg', '.jpeg')):
                with Image.open(file_path) as img:
                    exif_data = img._getexif()
                    if exif_data:
                        for tag_id, value in exif_data.items():
                            tag = TAGS.get(tag_id, tag_id)
                            if tag in ['DateTime', 'DateTimeOriginal', 'DateTimeDigitized']:
                                try:
                                    return datetime.strptime(value, '%Y:%m:%d %H:%M:%S')
                                except (ValueError, TypeError):
                                    continue
        except Exception:
            pass

        # Fallback to file modification time
        try:
            timestamp = os.path.getmtime(file_path)
            return datetime.fromtimestamp(timestamp)
        except OSError:
            return None

    def get_official_dir_name(self, file_path):

        path_parts = file_path.split(os.sep)
        directory_parts = path_parts[:-1]  # Remove filename

        # Strip leading "DCIM-" from all pieces
        cleaned_parts = [part[5:] if part.startswith('DCIM-') else part for part in directory_parts]

        for part in cleaned_parts:
            # Check for YYYYMMDD pattern
            if len(part) >= 8 and part[:8].isdigit():
                try:
                    datetime.strptime(part[:8], '%Y%m%d')
                    return part
                except ValueError:
                    pass

            # Check for YYYY-MM-DD pattern
            if len(part) >= 10 and part[4] == '-' and part[7] == '-':
                try:
                    date_part = part[:10]
                    datetime.strptime(date_part, '%Y-%m-%d')
                    return date_part.replace('-', '')
                except ValueError:
                    pass

            # Check for YYYY-nodate pattern
            if len(part) >= 4 and part[:4].isdigit() and '-nodate' in part:
                return part

        # If no pattern matches, use EXIF date
        exif_date = self.get_exif_date(file_path)
        if exif_date:
            return exif_date.strftime('%Y%m%d')
        else:
            return datetime.now().strftime('%Y%m%d')

    def should_process_directory(self, dir_path):

        if any(ignore_dir in dir_path for ignore_dir in self.ignore_list):
            return False

        has_subdirs = any(os.path.isdir(os.path.join(dir_path, item)) for item in os.listdir(dir_path))
        if has_subdirs:
            return True

        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isfile(item_path):
                ext = os.path.splitext(item)[1].lower()
                if ext in self.allowed_extensions:
                    return True

        return False

    def should_process_file(self, file_path, filename):

        # Check for files to delete
        if filename in self.delete_files:
            self.log_message(f"DELETE: {file_path}")
            if not self.dry_run:
                try:
                    os.remove(file_path)
                    self.stats['files_deleted'] += 1
                except OSError as e:
                    self.log_message(f"ERROR deleting {file_path}: {e}")
            return False

        # Check for prefixes to delete
        for prefix in self.delete_prefixes:
            if filename.startswith(prefix):
                self.log_message(f"DELETE: {file_path}")
                if not self.dry_run:
                    try:
                        os.remove(file_path)
                        self.stats['files_deleted'] += 1
                    except OSError as e:
                        self.log_message(f"ERROR deleting {file_path}: {e}")
                return False

        # Check for extensions to delete
        ext = os.path.splitext(filename)[1].lower()
        if ext in self.delete_extensions:
            self.log_message(f"DELETE: {file_path}")
            if not self.dry_run:
                try:
                    os.remove(file_path)
                    self.stats['files_deleted'] += 1
                except OSError as e:
                    self.log_message(f"ERROR deleting {file_path}: {e}")
            return False

        # Check date filter
        if self.date_filter:
            file_date = self.get_exif_date(file_path)
            if file_date and file_date < self.date_filter:
                self.log_message(f"SKIP (date filter): {file_path}")
                self.stats['files_skipped'] += 1
                return False

        return True

    def generate_unique_filename(self, target_dir, filename):

        base, ext = os.path.splitext(filename)
        counter = 1
        new_filename = filename
        target_path = os.path.join(target_dir, new_filename)

        while os.path.exists(target_path):
            new_filename = f"{base}_{counter:03d}{ext}"
            target_path = os.path.join(target_dir, new_filename)
            counter += 1

        return new_filename

    def should_rename_file(self, filename):

        # Check if filename starts with '-'
        if filename.startswith('-'):
            return True

        # Check if filename contains only more than 15 numbers
        name_without_ext = os.path.splitext(filename)[0]
        if name_without_ext.isdigit() and len(name_without_ext) > 15:
            return True

        return False

    def get_new_filename(self, file_path, filename):

        if not self.should_rename_file(filename):
            return filename

        exif_date = self.get_exif_date(file_path)
        if exif_date:
            timestamp = exif_date.strftime('%Y%m%d-%H%M%S')
        else:
            timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')

        ext = os.path.splitext(filename)[1].lower()
        return f"img-{timestamp}{ext}"

    def move_file(self, source_file, target_dir):

        filename = os.path.basename(source_file)

        if not self.should_process_file(source_file, filename):
            return

        # Get target directory name
        dir_name = self.get_official_dir_name(source_file)
        year = dir_name[:4] if len(dir_name) >= 4 else "unknown"

        final_target_dir = os.path.join(self.target_path, year, dir_name)

        # Create target directory if needed
        if not os.path.exists(final_target_dir):
            self.log_message(f"CREATE: {final_target_dir}")
            if not self.dry_run:
                os.makedirs(final_target_dir, exist_ok=True)

        # Determine new filename
        new_filename = self.get_new_filename(source_file, filename)
        target_file = os.path.join(final_target_dir, new_filename)

        # Check if file needs renaming due to conflicts
        if os.path.exists(target_file):
            source_size = os.path.getsize(source_file)
            target_size = os.path.getsize(target_file)

            if source_size == target_size:
                # Same file, overwrite
                self.log_message(f"OVERWRITE: {source_file} -> {target_file}")
                if not self.dry_run:
                    shutil.move(source_file, target_file)
                self.stats['files_moved_unchanged'] += 1
                return
            else:
                # Different files, generate unique name
                unique_filename = self.generate_unique_filename(final_target_dir, new_filename)
                target_file = os.path.join(final_target_dir, unique_filename)
                self.log_message(f"MOVE (renamed): {source_file} -> {target_file}")
                if not self.dry_run:
                    shutil.move(source_file, target_file)
                self.stats['files_moved_renamed'] += 1
                return
        else:
            # No conflict, move normally
            if new_filename != filename:
                self.log_message(f"MOVE (renamed): {source_file} -> {target_file}")
                self.stats['files_moved_renamed'] += 1
            else:
                self.log_message(f"MOVE: {source_file} -> {target_file}")
                self.stats['files_moved_unchanged'] += 1

            if not self.dry_run:
                shutil.move(source_file, target_file)

    def process_directory(self, dir_path):
        if not self.should_process_directory(dir_path):
            self.stats['directories_skipped'] += 1
            return

        self.stats['directories_processed'] += 1
        files_to_process = []

        try:
            for item in os.listdir(dir_path):
                item_path = os.path.join(dir_path, item)

                if os.path.isdir(item_path):
                    self.process_directory(item_path)
                elif os.path.isfile(item_path):
                    files_to_process.append(item_path)

            # Process files after processing subdirectories
            for file_path in files_to_process:
                self.move_file(file_path, dir_path)

            # Check if directory is empty and delete if so
            if not os.listdir(dir_path):
                self.log_message(f"DELETE DIRECTORY: {dir_path}")
                if not self.dry_run:
                    try:
                        os.rmdir(dir_path)
                        self.stats['directories_deleted'] += 1
                    except OSError as e:
                        self.log_message(f"ERROR deleting directory {dir_path}: {e}")

        except PermissionError as e:
            self.log_message(f"PERMISSION ERROR accessing {dir_path}: {e}")

    def run(self):

        self.setup_args()

        self.log_message(f"Starting photo organization")
        self.log_message(f"Source: {self.source_path}")
        self.log_message(f"Target: {self.target_path}")
        self.log_message(f"Dry run: {self.dry_run}")

        if not os.path.exists(self.source_path):
            self.log_message(f"ERROR: Source path does not exist: {self.source_path}")
            return

        # Create target root if it doesn't exist
        if not self.dry_run and not os.path.exists(self.target_path):
            os.makedirs(self.target_path, exist_ok=True)

        self.process_directory(self.source_path)

        # Print statistics
        self.log_message("\nSTATISTICS:")
        self.log_message(f"Directories processed: {self.stats['directories_processed']}")
        self.log_message(f"Directories skipped: {self.stats['directories_skipped']}")
        self.log_message(f"Directories deleted: {self.stats['directories_deleted']}")
        self.log_message(f"Files moved unchanged: {self.stats['files_moved_unchanged']}")
        self.log_message(f"Files moved renamed: {self.stats['files_moved_renamed']}")
        self.log_message(f"Files skipped: {self.stats['files_skipped']}")
        self.log_message(f"Files deleted: {self.stats['files_deleted']}")

if __name__ == '__main__':
    organizer = PhotoOrganizer()
    organizer.run()
